---
date: "2024-09-08T13:19:52+03:00"
description: ""
id: 724uw2yk1ni54d3fi5lugqf
publish: true
title: SSL
updated: 1725796858805
---

SSL (Secure Sockets Layer) — криптографический протокол, обеспечивающие защищенную передачу данных в сети.
Находится на [[organize.resource.it.network.osi|сессионном уровне модели OSI]].

Гарантирует:

- *безопасность* - передаваемая информация защищена от прочтения посторонними лицами
- *аунтификация* - можно опознать участников соединения
- *целостность* - можно проверить были ли данные изменены или утеряны в процессе передачи

## Что необходимо для использования SSL

Для использования SSL требуется обладать SSL Сертификатом, который выпускается авторитетным центром сертификации (Certification Authority).

Сертификат состоит из:
- название организации, которой он пренадлежит 
- название организации, выпустившей сертификат
- сигнатура организации, выпустившей сертификат
- ассоциируемые домены и поддомены
- дата истечения сертификата
- публичный ключ ассиметричного шифрования (приватный находится у сервера)

Требуемые сертификаты указаны ниже: CA X выдает сертификат клиенту TLS, а CA Y выдает сертификат серверу TLS:

1. Для аунтификации сервера клиентом

серверу TLS необходимы:

- Персональный сертификат, выданный серверу от CA Y
- Закрытый ключ сервера

клиенту TLS необходимы:

- Сертификат CA для CA Y

2. Для аунтификации сервера клиентом и клиента сервером:

серверу TLS необходимы:

- Персональный сертификат, выданный серверу от CA Y
- Закрытый ключ сервера
- Сертификат CA для CA X

клиенту TLS необходимы:

- Персональный сертификат, выданный клиенту от CA X
- Закрытый ключ клиента
- Сертификат CA для CA Y

---

Логику с наборами сертификатов проще понять, если понимать, как происходит ассиметричное шифрования и как строится цепочка доверия.

1. Для аунтификации сервера клиентом

- Сервер дает свой публичный ключ в CA Y и получает сертификат, который подписан приватным ключом CA Y. То есть CA Y гарантирует, что публичный ключ сервера принадлежит серверу и мы этому верим.
- Сервер передает клиенту сертификат
- Клиент знает публичный ключ CA Y и может расшифровать сертификат, чтобы узнать публичный ключ сервера.

2. Для аунтификации сервера клиентом и клиента сервером

Немного больше связей, но принцип тот же

- Сервер дает свой публичный ключ в CA Y и получает сертификат, который подписан приватным ключом CA Y. То есть CA Y гарантирует, что публичный ключ сервера принадлежит серверу и мы этому верим.
- Сервер передает клиенту сертификат
- Клиент знает публичный ключ CA Y и может расшифровать сертификат, чтобы узнать публичный ключ сервера.
- Клиент дает свой публичный ключ в CA X и получает сертификат, который подписан приватным ключом CA X. То есть CA X гарантирует, что публичный ключ клиента принадлежит клиенту и мы этому верим.
- Клиент передает серверу сертификат
- Сервер знает публичный ключ CA X и может расшифровать сертификат, чтобы узнать публичный ключ клиента.

Сверх указанных сертификатов и ключей, могут понадобиться дополнительные сертификаты для других CA в цепочке доверия.

## Принцип работы

Client Hello -> Server
    
    Клиент передает список информацию об используемом протоколе и доступных способах шифрования + случайное число `client_secret`

Client <- Hello Server 

    Сервер передает выбранный способ шифрования и настройки сессии + случайное число `server_secret`

Client <- Certificate Server

    Сервер передает свой *сертификат* для удостоверения стороны.
    Сервер передает свой публичный ключ.

Client Key -> Server

    Клиент проверяет сертификат сервера, обращаясь к авторитетному CA.
    Клиент генерирует случайное число `pre_master_secret` и, зашифровав его публичным ключом сервера, передает его серверу.
    
    Набор чисел `client_secret`, `server_secret`, `pre_master_secret` отдаются специальной функции для генерации `master_key`.
    На основе `client_secret`, `server_secret` и `master_key` генерируется секретный ключ для симметричного шифрования сообщений + генерируется MAC (message authentication code) отличный от секретного ключа.

Client Finish -> Server

    Клиент сообщает итоговые настройки шифрования и отправляет финиш.

Client <- Finish Server

    Сервер сообщает итоговые настройки шифрования и отправляет финиш.

Далее обмен данными происходит с помощью зашифрованных сообщений + MAC тега, посылаемого с каждым сообщением в зашифрованом виде.

## MAC (message authentication code)

<https://www.thesslstore.com/blog/what-is-a-message-authentication-code-mac/>

Код, который используется для специальных хэш функций.

MAC позволяет удостовериться в целостности сообщения и проверить аунтифицированного пользователя.

В отличии от обычных хэш функций, функции использующие MAC гарантируют проверку отправителя сообщения.
MAC тег для сообщения генерируется как h(сообщение + код) и добавляется к каждому сообщению, передаваемому с использованием SSL.
