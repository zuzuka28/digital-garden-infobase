---
date: "2024-07-02T20:48:40+03:00"
description: ""
id: 6iuvctu2ebetybn6zcf226v
publish: true
title: Mutex
updated: 1722584996764
---

<https://www.youtube.com/watch?v=KNHNqp1e9u8&list=PL4_hYwCyhAvalRjpPlvaCYPpPE8TL-fn3&index=1>

<https://deadlockempire.github.io> - прикольная игрушка про блокировки.

MUTual EXclusion - взаимное  исключение.

- mutex
  - определение
    - примитив для синхронизации доступа и исключения одновременного доступа потоков к памяти
  - операции
    - lock
      - mutex захватывается потоком
      - другие потоки при попытке заблокировать mutex будут ждать вызова unlock
    - unlock 
      - поток отпускает mutex
  - свойства
    - между операциями lock и unlock может находиться только один поток
      - *safety*
    - мьютекс захватывается только одним потоком (даже если его пытаются захватить несколько потоком)
      - *liveness*
  - реализация
    - простейший и самый первый - <https://en.wikipedia.org/wiki/Peterson%27s_algorithm>
  - preemption
     - мьютекс **не защищает** от вытеснения использующего его потока планировщиком OS

- spinlock
  - аналог mutex, защищает от одновременного доступа к памяти
  - используем Busy Lock, то есть просто ждет цикла **НА ПРОЦЕССОРЕ**
    - не круто, лучше не просто ждать, а использовать инструкцию `pause` при ожидании, чтобы не использовать ресурсы процессора
    - сделать syscall `yield` - попросить планировщик уступить ресурсы другому потоку
  - подходит для небольших критических секций. долгое держание spinlock впустую тратит процессорное время за счет кручения цикла.
    - сначала лучше использовать `pause` если ждать не долго, чтобы не делать context switching, а если ждать долго, то уже делать `yield` 
  - preemption
    - **защищает** от вытеснения планировщиком и его стоит использовать, когда слишком дорого делать context switching  
  - алгоритмы блокировок
    - <https://en.wikipedia.org/wiki/Test-and-set>
      - идея
        - поток захватывает спинлок и ставит ему состояние 1
        - все кто пытается захватить - крутятся пока состояние будет 0
        - при отпускании состояние становится 0
      - используется Read Update Write, то есть захват происходит атомарно ( не две атомарные операции чтения и записи, а одна! )
    - <https://en.wikipedia.org/wiki/Ticket_lock>
      - идея
        - каждый поток при попытке захвата получает "билет" - номер
        - спинлок хранит текущий номер билета и номер текущего владельца
        - не-владельцы крутятся
        - когда поток отпускает спинлок - номер владельца увеличивается, тем самым давая доступ следующему потоку
        - при **fair** реализации будет соблюден порядок выполения по билетам 
      - Используется Fetch And Add, то есть чтение и модификация происходит атомарно
  - Sleep lock
    - нельзя использовать `sleep` при реализации спинлоков, это тупо, поскольку мы не знаем сколько нужно спать
    - Futex API
      - очередь потоков в ядре OS, привязанная к ячейке памяти прогаммы
      - операции
        - FutexWait позволяет ждать, когда значение в ячейке сменится 
        - FutexWake позволяет разбудить n потоков из очереди связанной с ячейкой памяти

- burns-lynch theory
  - Любой протокол взаимного исключения для n потоков построенный только на атомарных операциях store и load использует по крайней мере n ячеек памяти.

- deadlock
  - потоки блокируются и не могут продолжать работу
- livelock
  - потоки мешают прогрессу друг друга, но при удачном планировании разойдутся
- thread safety
  - если все операции над объектом защищены мьютексом, то он потокобезопасен
    - в такой ситуации все операции будут последовательны

- C/C++ RAII
  - в C лучше не использовать ручной вызов мьютекса, поскольку при возникновении exeption стек развернется и unlock не будет вызван
  - лучше использовать `std::lock_guard<std::mutex> lock(mutex)`