---
date: "2024-07-09T21:40:27+03:00"
description: ""
id: 5m93nh8xyl0hzz36i7hc2n4
publish: true
title: Cache Coherence
updated: 1720601805371
---

<https://www.youtube.com/watch?v=lerIrAMzjWA>
<https://stackoverflow.com/questions/30684974/are-cache-line-ping-pong-and-false-sharing-the-same>

- shared memory

- процессорный кэш
  - обращение к памяти в *100* раз медленнее, чем работа с регистрами на процессоре.
  - чтобы не лезть в RAM, на процессоре сделали кэш
  - кэш представлен в виде иерархии
    - L1
    - L2
    - L3
  - запись в кэш происходит не по единичному попаданию, а целыми пачками последовательных адресов
    - пример - попытка читать список значений прогружает несколько элементов за раз в кэш
    - пример - плохой алгоритм по памяти - бинарный поиск. он берет не локальные значения, считай - случайные места в памяти.
    -  пример хорошего использования памяти - стековые виртуальные машины
-  SMP - Symmetric MultiProcessing
   -  N ядер и у каждого из ядер есть свой локальный кэш, а есть общая шина
   -  чтобы синхронизировать работу системы требуется протокол когерентрости
   -  [MSI](https://en.wikipedia.org/wiki/MSI_protocol) базовый протокол когерентности
      -  MSI state transition diagram
      -  каждый из кэшей у ядер может находиться в 3 состояниях
         -  Modified
            -  если в 1 modified, тогда в остальных будет Invalid
         -  Shared - чистый
            - каждый из кэшей может быть в shared или в invalid, но никто при этом не modified
         -  Invalid - грязный
      -  при изменении состояния кэша остальные кэши оповещаются
   - [MESI](https://en.wikipedia.org/wiki/MESI_protocol)
     - MESI state transition diagram
     - разделено состояние Shared на Shared и Exclusive
     - E - exclusive
       - переход в Modified только из этого состояния
       - переход в это состояние, когда все остальные не имеют значения в локальном кэше

- задача - сделать масштабируемый счетчик для конкурентного доступа
  - использовать fetch add
    - блокировка для эксклюзивного доступа - не конкурентная работа с счетчиком
  - шардировать счетчик
    - использовать массив из атомиков и суммировать его для получения результата
      - с таким массивом можно работать конкуррентно
      - массив попадает в одну кэш-линию в процессорном кэше и происходит опять эксклюзивный доступ из-за протокола когерентности - тоже не конкурентно 
        - ситуация в которой изменяемые данные попадают в одну кэш-линию и из-за этого делают другие кэши не валидными называют **False Sharing**
          - для избежания ситуации нужно избегать попадания шардированных счетчиков в одну линию процессорного кэша. можно использовать отступы в памяти с размером слова 64 бита
          - связанная ситуация - **Cache Ping-Pong**
            - постоянное изменение состояния локальных кэшей, нагружающее работу протокола когерентности

- интересные способы оптимизации исполнения критических секций с использованием улучшений работы протокола когерентности 
  - [MCS Lock](https://github.com/torvalds/linux/blob/master/kernel/locking/mcs_spinlock.h)
    - <https://read.seas.harvard.edu/cs161/2022/doc/wait-queues/>
  - [Combining Critical Sections](https://github.com/facebook/folly/blob/main/folly/synchronization/DistributedMutex.h)
    - идея в том, чтобы не бороться за кэш, а выполнять всю работу на одном ядре, если туда уже прогрузились данные
  - Lock Elision
    - Lock Elision for Protected Objects Using Intel Transactional Synchronization Extensions
    - процессорные транзакции