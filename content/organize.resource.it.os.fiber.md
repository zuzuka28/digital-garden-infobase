---
date: "2024-07-16T14:07:39+03:00"
description: ""
id: 7o48kp2m38u2x3dvj428hjs
publish: true
title: Fiber
updated: 1721128728049
---

Fiber - легковесный [[organize.resource.it.os.thread|поток]], использующий [[organize.resource.it.os.multitasking#кооперативная-многозадачность-cooperative-multitasking|кооперативную многозадачность]].

Fiber зачастую реализуется в пользовательском пространстве.  

---

<https://www.youtube.com/watch?v=SY3IcxvyPXw>
<https://gitlab.com/Lipovsky/tinyfiber>

- Control flow в ассемблере
  - instruction pointer
    - идет сверху вниз по программе и исполняет инструкции
  - `jmp`
    - переход к метке
  - `call` (функция)
    - помещает на стек адрес, куда нужно вернуться после выхода из функции
    - переход по метке к инструкциям функции
    - `ret` снимает адрес с стека, возврат на место, где был вызван `call`

- thread
  - fiber
    - в данном описании thread используется как виртуальный процессор, то есть описание работы fiber абстрагированно от вытеснений потоков планировщиком OS. 
    - работает в user space, никаких системных вызовов
    - fiber - легковесные "потоки" использующие кооперативную многозадачность
    - fiber используют один thread для исполнения, как thread использует процессор
    - интерфейс
      - `RunScheduler(<функция> init)` - запустить планировщик. С нее начинается исполнение кода.
        - исполняет функцию `init`
        - функция `init` вызывает функцию `Spawn(<функция> routine)`
        - функция `Spawn(<функция> routine)` висит и не исполняется до тех пор, пока не будет вызвана функция `Yield()`
      - `Spawn(<функция> routine)` - создать новый поток
      - `Yield()` - отпустить ядро, передать управление другому потоку
    - состав
      - routine (текст функции)
      - callstack (функции могут вызывать другие функции)
      - execution context (набор регистров для хранения данных)
      - state (состояние исполнения)
    - пример вызова функции в fiber с точки зрения состояния стека `SwitchTo(<контекст>)`
      - execution context save - сохранение состояния текущей функции в память
      - execution context activate - загрузка состояния вызываемой функции на процессор
      - справка о том как переключается контекст и какие регистры вызвавшего сохраняются
        - calling convention - <https://en.wikipedia.org/wiki/Calling_convention>
        - callee-saved
    - вызов `Yield`
      - при переключении на другой fiber происходит примерно такая последовательность действий source fiber  (`Yield()`)-> scheduler (`SwitchTo(<контекст>)`)-> target fiber.
      - scheduler хранит очередь запускаемых fiber и выбирает следующий запускаемый fiber 

